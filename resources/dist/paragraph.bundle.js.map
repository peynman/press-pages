{"version":3,"sources":["webpack:///./resources/js/Lib/vuetify-formjson/Fields/Paragraph.vue?9d17","webpack:///./resources/js/Lib/vuetify-formjson/Fields/Paragraph.vue?eaff","webpack:///resources/js/Lib/vuetify-formjson/Fields/Paragraph.vue","webpack:///./resources/js/Lib/vuetify-formjson/Fields/Paragraph.vue","webpack:///./node_modules/markdown-it-attrs/patterns.js","webpack:///./node_modules/markdown-it-attrs/utils.js","webpack:///./node_modules/markdown-it-attrs/index.js"],"names":["component","_vm","this","_h","$createElement","_c","_self","class","field","mode","_v","_s","label","_e","directives","name","rawName","value","readonly","expression","attrs","on","toggleVirtualMathKeyboard","dialog","modeIcon","ref","staticClass","staticStyle","style","height","VBtn","VCard","VIcon","utils","last","arr","slice","module","exports","options","__hr","RegExp","escapeRegExp","leftDelimiter","rightDelimiter","tests","shift","block","info","hasDelimiters","transform","tokens","i","token","start","lastIndexOf","getAttrs","addAttrs","removeDelimiter","type","children","str","content","j","endChar","indexOf","attrToken","length","splice","tableOpen","getMatchingOpeningToken","nesting","openingToken","position","ii","trimmed","match","tag","markup","t","s","replace","allowedKeyChars","key","parsingKey","valueInsideQuotes","push","char_","charAt","search","allowedAttributes","filter","attrPair","attr","some","allowedAttribute","test","l","attrJoin","attrPush","where","Error","end","nextChar","minCurlyLength","rightDelimiterMinimumShift","curly","isClass","isId","validCurlyLength","substring","pos","level","HTML_ESCAPE_TEST_RE","HTML_ESCAPE_REPLACE_RE","HTML_REPLACEMENTS","replaceUnsafeChar","ch","escapeHtml","patternsConfig","defaultOptions","res","undefined","n","isArrayOfObjects","childTests","every","tt","isArrayOfFunctions","Array","isArray","md","options_","Object","assign","patterns","core","ruler","before","state","p","pattern"],"mappings":"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","file":"paragraph.bundle.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:(\"vf-input d-flex flex-column flex-grow-1 \" + (_vm.field.class ? _vm.field.class : ''))},[(_vm.mode !== 'view')?_c('label',[_vm._v(_vm._s(_vm.field.label))]):_vm._e(),_vm._v(\" \"),_c('div',{directives:[{name:\"show\",rawName:\"v-show\",value:(!_vm.field.readonly),expression:\"!field.readonly\"}]},[_c('v-btn',{attrs:{\"fab\":\"\",\"small\":\"\",\"icon\":\"\"},on:{\"click\":function () { _vm.mode = _vm.mode === 'editor' ? 'view' : 'editor'; _vm.toggleVirtualMathKeyboard(_vm.dialog && _vm.mode === 'editor') }}},[_c('v-icon',{attrs:{\"small\":\"\"}},[_vm._v(_vm._s(_vm.modeIcon))])],1)],1),_vm._v(\" \"),_c('div',{directives:[{name:\"show\",rawName:\"v-show\",value:(_vm.mode === 'view' || _vm.field.readonly),expression:\"mode === 'view' || field.readonly\"}],ref:\"editorView\",staticClass:\"fill-height\",staticStyle:{\"width\":\"100%\"}}),_vm._v(\" \"),_c('v-card',{directives:[{name:\"show\",rawName:\"v-show\",value:(_vm.mode === 'editor' && !_vm.field.readonly),expression:\"mode === 'editor' && !field.readonly\"}],staticClass:\"fill-hight mx-2\",staticStyle:{\"position\":\"relative\",\"width\":\"100%\",\"min-height\":\"100px\",\"overflow\":\"scroll\"}},[_c('div',{ref:\"editorCode\",style:((\"position: absolute; width: 100%; left: 0; right: 0; top: 0; bottom: 0; \" + (_vm.field.height ? 'height: ' + _vm.field.height : '')))})])],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","import mod from \"-!../../../../../node_modules/babel-loader/lib/index.js??ref--4-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Paragraph.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../../../node_modules/babel-loader/lib/index.js??ref--4-0!../../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Paragraph.vue?vue&type=script&lang=js&\"","<template>\n<div :class=\"`vf-input d-flex flex-column flex-grow-1 ${field.class ? field.class : ''}`\">\n    <label v-if=\"mode !== 'view'\">{{ field.label }}</label>\n    <div v-show=\"!field.readonly\">\n        <v-btn fab small icon @click=\"() => { mode = mode === 'editor' ? 'view' : 'editor'; toggleVirtualMathKeyboard(dialog && mode === 'editor') }\">\n            <v-icon small>{{ modeIcon }}</v-icon>\n        </v-btn>\n    </div>\n    <div v-show=\"mode === 'view' || field.readonly\" ref=\"editorView\" class=\"fill-height\" style=\"width: 100%;\"></div>\n    <v-card v-show=\"mode === 'editor' && !field.readonly\" style=\"position: relative; width: 100%; min-height: 100px; overflow: scroll;\" class=\"fill-hight mx-2\">\n        <div class=\"\" :style=\"`position: absolute; width: 100%; left: 0; right: 0; top: 0; bottom: 0; ${field.height ? 'height: ' + field.height : ''}`\" ref=\"editorCode\">\n        </div>\n    </v-card>\n</div>\n</template>\n\n<script>\n// import MathLive from 'dist/mathlive.mjs'\nimport BaseComponent from './mixins'\nimport ACE from './MarkdownInput/AceEditor/ace'\nimport './MarkdownInput/AceEditor/mode-markdown'\nimport './MarkdownInput/AceEditor/theme-eclipse'\n\nimport markdownit from 'markdown-it'\nimport markdownItAttrs from 'markdown-it-attrs'\n\nimport {\n    VBtn,\n    VIcon,\n    VCard\n} from 'vuetify/lib'\nexport default {\n    components: {\n        VBtn,\n        VIcon,\n        VCard\n    },\n    mixins: [BaseComponent],\n    name: 'vf-paragraph-input',\n    props: {\n        id: String,\n        field: Object,\n        value: {\n            type: String,\n            default: () => ''\n        }\n    },\n    data: (vm) => ({\n        dialog: false,\n        markdownEditor: null,\n        mathfieldEditor: null,\n        mathKeyboardVisible: false,\n        aceEditor: null,\n        aceUpdate: false, // break devalue update <=> ace text update loop\n        mode: vm.field.readonly ? 'view' : 'editor'\n    }),\n    computed: {\n        modeIcon() {\n            return this.mode === 'editor' ? 'mdi-code-braces' : 'mdi-eye'\n        }\n    },\n    methods: {\n        toggleVirtualMathKeyboard(to) {\n            if (this.mathfieldEditor) {\n                if (this.mathfieldEditor.virtualKeyboardVisible !== to) {\n                    this.mathfieldEditor.$perform(['toggleVirtualKeyboard'])\n                }\n                this.mathKeyboardVisible = this.mathfieldEditor.virtualKeyboardVisible\n            }\n        },\n        //         insertMathToMarkdown() {\n        //             if (this.mathfieldEditor) {\n        //                 this.aceEditor.session.insert(this.aceEditor.getCursorPosition(), '\n        //  + this.mathfieldEditor.$text() + '\n        // )\n        //             }\n        //         },\n        updateMarkdownText() {\n            const markdownHtml = this.markdownEditor.render(this.devalue)\n            let child = this.$refs.editorView.lastElementChild\n            while (child) {\n                this.$refs.editorView.removeChild(child)\n                child = this.$refs.editorView.lastElementChild\n            }\n            this.$refs.editorView.insertAdjacentHTML('beforeend', markdownHtml)\n\n            if (!this.aceUpdate) {\n                this.aceEditor.session.setValue(this.devalue)\n            } else {\n                this.aceUpdate = false\n            }\n        }\n    },\n    watch: {\n        devalue: {\n            deep: true,\n            handler() {\n                this.updateMarkdownText()\n            }\n        }\n    },\n    mounted() {\n        this.aceEditor = ACE.edit(this.$refs.editorCode, {\n            mode: 'ace/mode/markdown',\n            selectionStyle: 'text',\n            theme: 'ace/theme/eclipse',\n            maxLines: Infinity\n        })\n        this.aceEditor.session.on('change', (delta) => {\n            this.aceUpdate = true\n            this.$nextTick(() => {\n                this.devalue = this.aceEditor.session.getValue()\n                this.$emit('input', this.devalue)\n            })\n        })\n        this.aceEditor.session.setValue(this.devalue)\n\n        // eslint-disable-next-line new-cap\n        this.markdownEditor = new markdownit((this.field.markdownProps ? this.field.markdownProps : {}))\n        // this.markdownEditor.use(MarkdownItColor, {\n        //     inline: true\n        // })\n        // this.markdownEditor.use(MermaidPlugin, {\n        //     host: this\n        // })\n        // this.markdownEditor.use(FromJSONPlugin, {\n        //     host: this\n        // })\n        // this.markdownEditor.use(MathLivePlugin, {\n        //     host: this\n        // })\n        this.markdownEditor.use(markdownItAttrs, {\n            // optional, these are default options\n            leftDelimiter: '{',\n            rightDelimiter: '}',\n            allowedAttributes: [] // empty array = all attributes are allowed\n        });\n        // init ace editor before calling update\n        this.updateMarkdownText()\n    }\n}\n</script>\n","import { render, staticRenderFns } from \"./Paragraph.vue?vue&type=template&id=3e5496b0&\"\nimport script from \"./Paragraph.vue?vue&type=script&lang=js&\"\nexport * from \"./Paragraph.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports\n\n/* vuetify-loader */\nimport installComponents from \"!../../../../../node_modules/vuetify-loader/lib/runtime/installComponents.js\"\nimport { VBtn } from 'vuetify/lib/components/VBtn';\nimport { VCard } from 'vuetify/lib/components/VCard';\nimport { VIcon } from 'vuetify/lib/components/VIcon';\ninstallComponents(component, {VBtn,VCard,VIcon})\n","'use strict';\n/**\n * If a pattern matches the token stream,\n * then run transform.\n */\n\nconst utils = require('./utils.js');\n\nmodule.exports = options => {\n  const __hr = new RegExp('^ {0,3}[-*_]{3,} ?'\n                          + utils.escapeRegExp(options.leftDelimiter)\n                          + '[^' + utils.escapeRegExp(options.rightDelimiter) + ']');\n\n  return ([\n    {\n      /**\n       * ```python {.cls}\n       * for i in range(10):\n       *     print(i)\n       * ```\n       */\n      name: 'fenced code blocks',\n      tests: [\n        {\n          shift: 0,\n          block: true,\n          info: utils.hasDelimiters('end', options)\n        }\n      ],\n      transform: (tokens, i) => {\n        let token = tokens[i];\n        let start = token.info.lastIndexOf(options.leftDelimiter);\n        let attrs = utils.getAttrs(token.info, start, options);\n        utils.addAttrs(attrs, token);\n        token.info = utils.removeDelimiter(token.info, options);\n      }\n    }, {\n      /**\n       * bla `click()`{.c} ![](img.png){.d}\n       *\n       * differs from 'inline attributes' as it does\n       * not have a closing tag (nesting: -1)\n       */\n      name: 'inline nesting 0',\n      tests: [\n        {\n          shift: 0,\n          type: 'inline',\n          children: [\n            {\n              shift: -1,\n              type: (str) => str === 'image' || str === 'code_inline'\n            }, {\n              shift: 0,\n              type: 'text',\n              content: utils.hasDelimiters('start', options)\n            }\n          ]\n        }\n      ],\n      transform: (tokens, i, j) => {\n        let token = tokens[i].children[j];\n        let endChar = token.content.indexOf(options.rightDelimiter);\n        let attrToken = tokens[i].children[j - 1];\n        let attrs = utils.getAttrs(token.content, 0, options);\n        utils.addAttrs(attrs, attrToken);\n        if (token.content.length === (endChar + options.rightDelimiter.length)) {\n          tokens[i].children.splice(j, 1);\n        } else {\n          token.content = token.content.slice(endChar + options.rightDelimiter.length);\n        }\n      }\n    }, {\n      /**\n       * | h1 |\n       * | -- |\n       * | c1 |\n       * {.c}\n       */\n      name: 'tables',\n      tests: [\n        {\n          // let this token be i, such that for-loop continues at\n          // next token after tokens.splice\n          shift: 0,\n          type: 'table_close'\n        }, {\n          shift: 1,\n          type: 'paragraph_open'\n        }, {\n          shift: 2,\n          type: 'inline',\n          content: utils.hasDelimiters('only', options)\n        }\n      ],\n      transform: (tokens, i) => {\n        let token = tokens[i + 2];\n        let tableOpen = utils.getMatchingOpeningToken(tokens, i);\n        let attrs = utils.getAttrs(token.content, 0, options);\n        // add attributes\n        utils.addAttrs(attrs, tableOpen);\n        // remove <p>{.c}</p>\n        tokens.splice(i + 1, 3);\n      }\n    }, {\n      /**\n       * *emphasis*{.with attrs=1}\n       */\n      name: 'inline attributes',\n      tests: [\n        {\n          shift: 0,\n          type: 'inline',\n          children: [\n            {\n              shift: -1,\n              nesting: -1  // closing inline tag, </em>{.a}\n            }, {\n              shift: 0,\n              type: 'text',\n              content: utils.hasDelimiters('start', options)\n            }\n          ]\n        }\n      ],\n      transform: (tokens, i, j) => {\n        let token = tokens[i].children[j];\n        let content = token.content;\n        let attrs = utils.getAttrs(content, 0, options);\n        let openingToken = utils.getMatchingOpeningToken(tokens[i].children, j - 1);\n        utils.addAttrs(attrs, openingToken);\n        token.content = content.slice(content.indexOf(options.rightDelimiter) + options.rightDelimiter.length);\n      }\n    }, {\n      /**\n       * - item\n       * {.a}\n       */\n      name: 'list softbreak',\n      tests: [\n        {\n          shift: -2,\n          type: 'list_item_open'\n        }, {\n          shift: 0,\n          type: 'inline',\n          children: [\n            {\n              position: -2,\n              type: 'softbreak'\n            }, {\n              position: -1,\n              type: 'text',\n              content: utils.hasDelimiters('only', options)\n            }\n          ]\n        }\n      ],\n      transform: (tokens, i, j) => {\n        let token = tokens[i].children[j];\n        let content = token.content;\n        let attrs = utils.getAttrs(content, 0, options);\n        let ii = i - 2;\n        while (tokens[ii - 1] &&\n          tokens[ii - 1].type !== 'ordered_list_open' &&\n          tokens[ii - 1].type !== 'bullet_list_open') { ii--; }\n        utils.addAttrs(attrs, tokens[ii - 1]);\n        tokens[i].children = tokens[i].children.slice(0, -2);\n      }\n    }, {\n      /**\n       * - nested list\n       *   - with double \\n\n       *   {.a} <-- apply to nested ul\n       *\n       * {.b} <-- apply to root <ul>\n       */\n      name: 'list double softbreak',\n      tests: [\n        {\n          // let this token be i = 0 so that we can erase\n          // the <p>{.a}</p> tokens below\n          shift: 0,\n          type: (str) =>\n            str === 'bullet_list_close' ||\n            str === 'ordered_list_close'\n        }, {\n          shift: 1,\n          type: 'paragraph_open'\n        }, {\n          shift: 2,\n          type: 'inline',\n          content: utils.hasDelimiters('only', options),\n          children: (arr) => arr.length === 1\n        }, {\n          shift: 3,\n          type: 'paragraph_close'\n        }\n      ],\n      transform: (tokens, i) => {\n        let token = tokens[i + 2];\n        let content = token.content;\n        let attrs = utils.getAttrs(content, 0, options);\n        let openingToken = utils.getMatchingOpeningToken(tokens, i);\n        utils.addAttrs(attrs, openingToken);\n        tokens.splice(i + 1, 3);\n      }\n    }, {\n      /**\n       * - end of {.list-item}\n       */\n      name: 'list item end',\n      tests: [\n        {\n          shift: -2,\n          type: 'list_item_open'\n        }, {\n          shift: 0,\n          type: 'inline',\n          children: [\n            {\n              position: -1,\n              type: 'text',\n              content: utils.hasDelimiters('end', options)\n            }\n          ]\n        }\n      ],\n      transform: (tokens, i, j) => {\n        let token = tokens[i].children[j];\n        let content = token.content;\n        let attrs = utils.getAttrs(content, content.lastIndexOf(options.leftDelimiter), options);\n        utils.addAttrs(attrs, tokens[i - 2]);\n        let trimmed = content.slice(0, content.lastIndexOf(options.leftDelimiter));\n        token.content = last(trimmed) !== ' ' ?\n          trimmed : trimmed.slice(0, -1);\n      }\n    }, {\n      /**\n       * something with softbreak\n       * {.cls}\n       */\n      name: '\\n{.a} softbreak then curly in start',\n      tests: [\n        {\n          shift: 0,\n          type: 'inline',\n          children: [\n            {\n              position: -2,\n              type: 'softbreak'\n            }, {\n              position: -1,\n              type: 'text',\n              content: utils.hasDelimiters('only', options)\n            }\n          ]\n        }\n      ],\n      transform: (tokens, i, j) => {\n        let token = tokens[i].children[j];\n        let attrs = utils.getAttrs(token.content, 0, options);\n        // find last closing tag\n        let ii = i + 1;\n        while (tokens[ii + 1] && tokens[ii + 1].nesting === -1) { ii++; }\n        let openingToken = utils.getMatchingOpeningToken(tokens, ii);\n        utils.addAttrs(attrs, openingToken);\n        tokens[i].children = tokens[i].children.slice(0, -2);\n      }\n    }, {\n      /**\n       * horizontal rule --- {#id}\n       */\n      name: 'horizontal rule',\n      tests: [\n        {\n          shift: 0,\n          type: 'paragraph_open'\n        },\n        {\n          shift: 1,\n          type: 'inline',\n          children: (arr) => arr.length === 1,\n          content: (str) => str.match(__hr) !== null,\n        },\n        {\n          shift: 2,\n          type: 'paragraph_close'\n        }\n      ],\n      transform: (tokens, i) => {\n        let token = tokens[i];\n        token.type = 'hr';\n        token.tag = 'hr';\n        token.nesting = 0;\n        let content = tokens[i + 1].content;\n        let start = content.lastIndexOf(options.leftDelimiter);\n        token.attrs = utils.getAttrs(content, start, options);\n        token.markup = content;\n        tokens.splice(i + 1, 2);\n      }\n    }, {\n      /**\n       * end of {.block}\n       */\n      name: 'end of block',\n      tests: [\n        {\n          shift: 0,\n          type: 'inline',\n          children: [\n            {\n              position: -1,\n              content: utils.hasDelimiters('end', options),\n              type: (t) => t !== 'code_inline'\n            }\n          ]\n        }\n      ],\n      transform: (tokens, i, j) => {\n        let token = tokens[i].children[j];\n        let content = token.content;\n        let attrs = utils.getAttrs(content, content.lastIndexOf(options.leftDelimiter), options);\n        let ii = i + 1;\n        while (tokens[ii + 1] && tokens[ii + 1].nesting === -1) { ii++; }\n        let openingToken = utils.getMatchingOpeningToken(tokens, ii);\n        utils.addAttrs(attrs, openingToken);\n        let trimmed = content.slice(0, content.lastIndexOf(options.leftDelimiter));\n        token.content = last(trimmed) !== ' ' ?\n          trimmed : trimmed.slice(0, -1);\n      }\n    }\n  ]);\n};\n\n// get last element of array or string\nfunction last(arr) {\n  return arr.slice(-1)[0];\n}\n","'use strict';\n/**\n * parse {.class #id key=val} strings\n * @param {string} str: string to parse\n * @param {int} start: where to start parsing (including {)\n * @returns {2d array}: [['key', 'val'], ['class', 'red']]\n */\nexports.getAttrs = function (str, start, options) {\n  // not tab, line feed, form feed, space, solidus, greater than sign, quotation mark, apostrophe and equals sign\n  const allowedKeyChars = /[^\\t\\n\\f />\"'=]/;\n  const pairSeparator = ' ';\n  const keySeparator = '=';\n  const classChar = '.';\n  const idChar = '#';\n\n  const attrs = [];\n  let key = '';\n  let value = '';\n  let parsingKey = true;\n  let valueInsideQuotes = false;\n\n  // read inside {}\n  // start + left delimiter length to avoid beginning {\n  // breaks when } is found or end of string\n  for (let i = start + options.leftDelimiter.length; i < str.length; i++) {\n    if (str.slice(i, i + options.rightDelimiter.length) === options.rightDelimiter) {\n      if (key !== '') { attrs.push([key, value]); }\n      break;\n    }\n    let char_ = str.charAt(i);\n\n    // switch to reading value if equal sign\n    if (char_ === keySeparator && parsingKey) {\n      parsingKey = false;\n      continue;\n    }\n\n    // {.class} {..css-module}\n    if (char_ === classChar && key === '') {\n      if (str.charAt(i + 1) === classChar) {\n        key = 'css-module';\n        i += 1;\n      } else {\n        key = 'class';\n      }\n      parsingKey = false;\n      continue;\n    }\n\n    // {#id}\n    if (char_ === idChar && key === '') {\n      key = 'id';\n      parsingKey = false;\n      continue;\n    }\n\n    // {value=\"inside quotes\"}\n    if (char_ === '\"' && value === '') {\n      valueInsideQuotes = true;\n      continue;\n    }\n    if (char_ === '\"' && valueInsideQuotes) {\n      valueInsideQuotes = false;\n      continue;\n    }\n\n    // read next key/value pair\n    if ((char_ === pairSeparator && !valueInsideQuotes)) {\n      if (key === '') {\n        // beginning or ending space: { .red } vs {.red}\n        continue;\n      }\n      attrs.push([key, value]);\n      key = '';\n      value = '';\n      parsingKey = true;\n      continue;\n    }\n\n    // continue if character not allowed\n    if (parsingKey && char_.search(allowedKeyChars) === -1) {\n      continue;\n    }\n\n    // no other conditions met; append to key/value\n    if (parsingKey) {\n      key += char_;\n      continue;\n    }\n    value += char_;\n  }\n\n  if (options.allowedAttributes && options.allowedAttributes.length) {\n    let allowedAttributes = options.allowedAttributes;\n\n    return attrs.filter(function (attrPair) {\n      let attr = attrPair[0];\n\n      function isAllowedAttribute (allowedAttribute) {\n        return (attr === allowedAttribute\n          || (allowedAttribute instanceof RegExp && allowedAttribute.test(attr))\n        );\n      }\n\n      return allowedAttributes.some(isAllowedAttribute);\n    });\n\n  } else {\n    return attrs;\n  }\n};\n\n/**\n * add attributes from [['key', 'val']] list\n * @param {array} attrs: [['key', 'val']]\n * @param {token} token: which token to add attributes\n * @returns token\n */\nexports.addAttrs = function (attrs, token) {\n  for (let j = 0, l = attrs.length; j < l; ++j) {\n    let key = attrs[j][0];\n    if (key === 'class') {\n      token.attrJoin('class', attrs[j][1]);\n    } else if (key === 'css-module') {\n      token.attrJoin('css-module', attrs[j][1]);\n    } else {\n      token.attrPush(attrs[j]);\n    }\n  }\n  return token;\n};\n\n/**\n * Does string have properly formatted curly?\n *\n * start: '{.a} asdf'\n * middle: 'a{.b}c'\n * end: 'asdf {.a}'\n * only: '{.a}'\n *\n * @param {string} where to expect {} curly. start, middle, end or only.\n * @return {function(string)} Function which testes if string has curly.\n */\nexports.hasDelimiters = function (where, options) {\n\n  if (!where) {\n    throw new Error('Parameter `where` not passed. Should be \"start\", \"middle\", \"end\" or \"only\".');\n  }\n\n  /**\n   * @param {string} str\n   * @return {boolean}\n   */\n  return function (str) {\n    // we need minimum three chars, for example {b}\n    let minCurlyLength = options.leftDelimiter.length + 1 + options.rightDelimiter.length;\n    if (!str || typeof str !== 'string' || str.length < minCurlyLength) {\n      return false;\n    }\n\n    function validCurlyLength (curly) {\n      let isClass = curly.charAt(options.leftDelimiter.length) === '.';\n      let isId = curly.charAt(options.leftDelimiter.length) === '#';\n      return (isClass || isId)\n        ? curly.length >= (minCurlyLength + 1)\n        : curly.length >= minCurlyLength;\n    }\n\n    let start, end, slice, nextChar;\n    let rightDelimiterMinimumShift = minCurlyLength - options.rightDelimiter.length;\n    switch (where) {\n    case 'start':\n      // first char should be {, } found in char 2 or more\n      slice = str.slice(0, options.leftDelimiter.length);\n      start = slice === options.leftDelimiter ? 0 : -1;\n      end = start === -1 ? -1 : str.indexOf(options.rightDelimiter, rightDelimiterMinimumShift);\n      // check if next character is not one of the delimiters\n      nextChar = str.charAt(end + options.rightDelimiter.length);\n      if (nextChar && options.rightDelimiter.indexOf(nextChar) !== -1) {\n        end = -1;\n      }\n      break;\n\n    case 'end':\n      // last char should be }\n      start = str.lastIndexOf(options.leftDelimiter);\n      end = start === -1 ? -1 : str.indexOf(options.rightDelimiter, start + rightDelimiterMinimumShift);\n      end = end === str.length - options.rightDelimiter.length ? end : -1;\n      break;\n\n    case 'only':\n      // '{.a}'\n      slice = str.slice(0, options.leftDelimiter.length);\n      start = slice === options.leftDelimiter ? 0 : -1;\n      slice = str.slice(str.length - options.rightDelimiter.length);\n      end = slice === options.rightDelimiter ? str.length - options.rightDelimiter.length : -1;\n      break;\n    }\n\n    return start !== -1 && end !== -1 && validCurlyLength(str.substring(start, end + options.rightDelimiter.length));\n  };\n};\n\n/**\n * Removes last curly from string.\n */\nexports.removeDelimiter = function (str, options) {\n  const start = escapeRegExp(options.leftDelimiter);\n  const end = escapeRegExp(options.rightDelimiter);\n\n  let curly = new RegExp(\n    '[ \\\\n]?' + start + '[^' + start + end + ']+' + end + '$'\n  );\n  let pos = str.search(curly);\n\n  return pos !== -1 ? str.slice(0, pos) : str;\n};\n\n/**\n * Escapes special characters in string s such that the string\n * can be used in `new RegExp`. For example \"[\" becomes \"\\\\[\".\n *\n * @param {string} s Regex string.\n * @return {string} Escaped string.\n */\nfunction escapeRegExp (s) {\n  return s.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\nexports.escapeRegExp = escapeRegExp;\n\n/**\n * find corresponding opening block\n */\nexports.getMatchingOpeningToken = function (tokens, i) {\n  if (tokens[i].type === 'softbreak') {\n    return false;\n  }\n  // non closing blocks, example img\n  if (tokens[i].nesting === 0) {\n    return tokens[i];\n  }\n\n  let level = tokens[i].level;\n  let type = tokens[i].type.replace('_close', '_open');\n\n  for (; i >= 0; --i) {\n    if (tokens[i].type === type && tokens[i].level === level) {\n      return tokens[i];\n    }\n  }\n};\n\n\n/**\n * from https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js\n */\nlet HTML_ESCAPE_TEST_RE = /[&<>\"]/;\nlet HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g;\nlet HTML_REPLACEMENTS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;'\n};\n\nfunction replaceUnsafeChar(ch) {\n  return HTML_REPLACEMENTS[ch];\n}\n\nexports.escapeHtml = function (str) {\n  if (HTML_ESCAPE_TEST_RE.test(str)) {\n    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);\n  }\n  return str;\n};\n","'use strict';\n\nconst patternsConfig = require('./patterns.js');\n\nconst defaultOptions = {\n  leftDelimiter: '{',\n  rightDelimiter: '}',\n  allowedAttributes: []\n};\n\nmodule.exports = function attributes(md, options_) {\n  let options = Object.assign({}, defaultOptions);\n  options = Object.assign(options, options_);\n\n  const patterns = patternsConfig(options);\n\n  function curlyAttrs(state) {\n    let tokens = state.tokens;\n\n    for (let i = 0; i < tokens.length; i++) {\n      for (let p = 0; p < patterns.length; p++) {\n        let pattern = patterns[p];\n        let j = null; // position of child with offset 0\n        let match = pattern.tests.every(t => {\n          let res = test(tokens, i, t);\n          if (res.j !== null) { j = res.j; }\n          return res.match;\n        });\n        if (match) {\n          pattern.transform(tokens, i, j);\n          if (pattern.name === 'inline attributes' || pattern.name === 'inline nesting 0') {\n            // retry, may be several inline attributes\n            p--;\n          }\n        }\n      }\n    }\n  }\n\n  md.core.ruler.before('linkify', 'curly_attributes', curlyAttrs);\n};\n\n/**\n * Test if t matches token stream.\n *\n * @param {array} tokens\n * @param {number} i\n * @param {object} t Test to match.\n * @return {object} { match: true|false, j: null|number }\n */\nfunction test(tokens, i, t) {\n  let res = {\n    match: false,\n    j: null  // position of child\n  };\n\n  let ii = t.shift !== undefined\n    ? i + t.shift\n    : t.position;\n  let token = get(tokens, ii);  // supports negative ii\n\n\n  if (token === undefined) { return res; }\n\n  for (let key in t) {\n    if (key === 'shift' || key === 'position') { continue; }\n\n    if (token[key] === undefined) { return res; }\n\n    if (key === 'children' && isArrayOfObjects(t.children)) {\n      if (token.children.length === 0) {\n        return res;\n      }\n      let match;\n      let childTests = t.children;\n      let children = token.children;\n      if (childTests.every(tt => tt.position !== undefined)) {\n        // positions instead of shifts, do not loop all children\n        match = childTests.every(tt => test(children, tt.position, tt).match);\n        if (match) {\n          // we may need position of child in transform\n          let j = last(childTests).position;\n          res.j = j >= 0 ? j : children.length + j;\n        }\n      } else {\n        for (let j = 0; j < children.length; j++) {\n          match = childTests.every(tt => test(children, j, tt).match);\n          if (match) {\n            res.j = j;\n            // all tests true, continue with next key of pattern t\n            break;\n          }\n        }\n      }\n\n      if (match === false) { return res; }\n\n      continue;\n    }\n\n    switch (typeof t[key]) {\n    case 'boolean':\n    case 'number':\n    case 'string':\n      if (token[key] !== t[key]) { return res; }\n      break;\n    case 'function':\n      if (!t[key](token[key])) { return res; }\n      break;\n    case 'object':\n      if (isArrayOfFunctions(t[key])) {\n        let r = t[key].every(tt => tt(token[key]));\n        if (r === false) { return res; }\n        break;\n      }\n    // fall through for objects !== arrays of functions\n    default:\n      throw new Error(`Unknown type of pattern test (key: ${key}). Test should be of type boolean, number, string, function or array of functions.`);\n    }\n  }\n\n  // no tests returned false -> all tests returns true\n  res.match = true;\n  return res;\n}\n\nfunction isArrayOfObjects(arr) {\n  return Array.isArray(arr) && arr.length && arr.every(i => typeof i === 'object');\n}\n\nfunction isArrayOfFunctions(arr) {\n  return Array.isArray(arr) && arr.length && arr.every(i => typeof i === 'function');\n}\n\n/**\n * Get n item of array. Supports negative n, where -1 is last\n * element in array.\n * @param {array} arr\n * @param {number} n\n */\nfunction get(arr, n) {\n  return n >= 0 ? arr[n] : arr[arr.length + n];\n}\n\n// get last element of array, safe - returns {} if not found\nfunction last(arr) {\n  return arr.slice(-1)[0] || {};\n}\n"],"sourceRoot":""}