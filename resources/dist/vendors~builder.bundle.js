(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~builder"],{

/***/ "./node_modules/find-insert-index/index.js":
/*!*************************************************!*\
  !*** ./node_modules/find-insert-index/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = (function () {\n  'use strict';\n\n  /**\n   * Find the index to insert an element in array keeping the sort order.\n   *\n   * @param {function} comparatorFn The comparator function which sorted the array.\n   * @param {array} arr The sorted array.\n   * @param {object} el The element to insert.\n   */\n  function findInsertIndex(comparatorFn, arr, el) {\n    var i, len;\n    for (i = 0, len = arr.length; i < len; i++) {\n      if (comparatorFn(arr[i], el) > 0) {\n        break;\n      }\n    }\n    return i;\n  }\n\n  return findInsertIndex;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmluZC1pbnNlcnQtaW5kZXgvaW5kZXguanM/Zjc0MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmluZC1pbnNlcnQtaW5kZXgvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogRmluZCB0aGUgaW5kZXggdG8gaW5zZXJ0IGFuIGVsZW1lbnQgaW4gYXJyYXkga2VlcGluZyB0aGUgc29ydCBvcmRlci5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvckZuIFRoZSBjb21wYXJhdG9yIGZ1bmN0aW9uIHdoaWNoIHNvcnRlZCB0aGUgYXJyYXkuXG4gICAqIEBwYXJhbSB7YXJyYXl9IGFyciBUaGUgc29ydGVkIGFycmF5LlxuICAgKiBAcGFyYW0ge29iamVjdH0gZWwgVGhlIGVsZW1lbnQgdG8gaW5zZXJ0LlxuICAgKi9cbiAgZnVuY3Rpb24gZmluZEluc2VydEluZGV4KGNvbXBhcmF0b3JGbiwgYXJyLCBlbCkge1xuICAgIHZhciBpLCBsZW47XG4gICAgZm9yIChpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoY29tcGFyYXRvckZuKGFycltpXSwgZWwpID4gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cblxuICByZXR1cm4gZmluZEluc2VydEluZGV4O1xufSkoKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/find-insert-index/index.js\n");

/***/ }),

/***/ "./node_modules/mergesort/index.js":
/*!*****************************************!*\
  !*** ./node_modules/mergesort/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = (function () {\n  'use strict';\n\n  /**\n   * Sort an array using the merge sort algorithm.\n   *\n   * @param {function} comparatorFn The comparator function.\n   * @param {array} arr The array to sort.\n   * @returns {array} The sorted array.\n   */\n  function mergeSort(comparatorFn, arr) {\n    var len = arr.length, firstHalf, secondHalf;\n    if (len >= 2) {\n      firstHalf = arr.slice(0, len / 2);\n      secondHalf = arr.slice(len / 2, len);\n      return merge(comparatorFn, mergeSort(comparatorFn, firstHalf), mergeSort(comparatorFn, secondHalf));\n    } else {\n      return arr.slice();\n    }\n  }\n\n  /**\n   * The merge part of the merge sort algorithm.\n   *\n   * @param {function} comparatorFn The comparator function.\n   * @param {array} arr1 The first sorted array.\n   * @param {array} arr2 The second sorted array.\n   * @returns {array} The merged and sorted array.\n   */\n  function merge(comparatorFn, arr1, arr2) {\n    var result = [], left1 = arr1.length, left2 = arr2.length;\n    while (left1 > 0 && left2 > 0) {\n      if (comparatorFn(arr1[0], arr2[0]) <= 0) {\n        result.push(arr1.shift());\n        left1--;\n      } else {\n        result.push(arr2.shift());\n        left2--;\n      }\n    }\n    if (left1 > 0) {\n      result.push.apply(result, arr1);\n    } else {\n      result.push.apply(result, arr2);\n    }\n    return result;\n  }\n\n  return mergeSort;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWVyZ2Vzb3J0L2luZGV4LmpzPzRkODkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxNQUFNO0FBQ25CLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsTUFBTTtBQUNuQixhQUFhLE1BQU07QUFDbkIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVyZ2Vzb3J0L2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIFNvcnQgYW4gYXJyYXkgdXNpbmcgdGhlIG1lcmdlIHNvcnQgYWxnb3JpdGhtLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yRm4gVGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7YXJyYXl9IGFyciBUaGUgYXJyYXkgdG8gc29ydC5cbiAgICogQHJldHVybnMge2FycmF5fSBUaGUgc29ydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gbWVyZ2VTb3J0KGNvbXBhcmF0b3JGbiwgYXJyKSB7XG4gICAgdmFyIGxlbiA9IGFyci5sZW5ndGgsIGZpcnN0SGFsZiwgc2Vjb25kSGFsZjtcbiAgICBpZiAobGVuID49IDIpIHtcbiAgICAgIGZpcnN0SGFsZiA9IGFyci5zbGljZSgwLCBsZW4gLyAyKTtcbiAgICAgIHNlY29uZEhhbGYgPSBhcnIuc2xpY2UobGVuIC8gMiwgbGVuKTtcbiAgICAgIHJldHVybiBtZXJnZShjb21wYXJhdG9yRm4sIG1lcmdlU29ydChjb21wYXJhdG9yRm4sIGZpcnN0SGFsZiksIG1lcmdlU29ydChjb21wYXJhdG9yRm4sIHNlY29uZEhhbGYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFyci5zbGljZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbWVyZ2UgcGFydCBvZiB0aGUgbWVyZ2Ugc29ydCBhbGdvcml0aG0uXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JGbiBUaGUgY29tcGFyYXRvciBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHthcnJheX0gYXJyMSBUaGUgZmlyc3Qgc29ydGVkIGFycmF5LlxuICAgKiBAcGFyYW0ge2FycmF5fSBhcnIyIFRoZSBzZWNvbmQgc29ydGVkIGFycmF5LlxuICAgKiBAcmV0dXJucyB7YXJyYXl9IFRoZSBtZXJnZWQgYW5kIHNvcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIG1lcmdlKGNvbXBhcmF0b3JGbiwgYXJyMSwgYXJyMikge1xuICAgIHZhciByZXN1bHQgPSBbXSwgbGVmdDEgPSBhcnIxLmxlbmd0aCwgbGVmdDIgPSBhcnIyLmxlbmd0aDtcbiAgICB3aGlsZSAobGVmdDEgPiAwICYmIGxlZnQyID4gMCkge1xuICAgICAgaWYgKGNvbXBhcmF0b3JGbihhcnIxWzBdLCBhcnIyWzBdKSA8PSAwKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGFycjEuc2hpZnQoKSk7XG4gICAgICAgIGxlZnQxLS07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChhcnIyLnNoaWZ0KCkpO1xuICAgICAgICBsZWZ0Mi0tO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVmdDEgPiAwKSB7XG4gICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIGFycjEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIGFycjIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIG1lcmdlU29ydDtcbn0pKCk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mergesort/index.js\n");

/***/ }),

/***/ "./node_modules/tree-model/index.js":
/*!******************************************!*\
  !*** ./node_modules/tree-model/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var mergeSort, findInsertIndex;\nmergeSort = __webpack_require__(/*! mergesort */ \"./node_modules/mergesort/index.js\");\nfindInsertIndex = __webpack_require__(/*! find-insert-index */ \"./node_modules/find-insert-index/index.js\");\n\nmodule.exports = (function () {\n  'use strict';\n\n  var walkStrategies;\n\n  walkStrategies = {};\n\n  function k(result) {\n    return function () {\n      return result;\n    };\n  }\n\n  function TreeModel(config) {\n    config = config || {};\n    this.config = config;\n    this.config.childrenPropertyName = config.childrenPropertyName || 'children';\n    this.config.modelComparatorFn = config.modelComparatorFn;\n  }\n\n  function addChildToNode(node, child) {\n    child.parent = node;\n    node.children.push(child);\n    return child;\n  }\n\n  function Node(config, model) {\n    this.config = config;\n    this.model = model;\n    this.children = [];\n  }\n\n  TreeModel.prototype.parse = function (model) {\n    var i, childCount, node;\n\n    if (!(model instanceof Object)) {\n      throw new TypeError('Model must be of type object.');\n    }\n\n    node = new Node(this.config, model);\n    if (model[this.config.childrenPropertyName] instanceof Array) {\n      if (this.config.modelComparatorFn) {\n        model[this.config.childrenPropertyName] = mergeSort(\n          this.config.modelComparatorFn,\n          model[this.config.childrenPropertyName]);\n      }\n      for (i = 0, childCount = model[this.config.childrenPropertyName].length; i < childCount; i++) {\n        addChildToNode(node, this.parse(model[this.config.childrenPropertyName][i]));\n      }\n    }\n    return node;\n  };\n\n  function hasComparatorFunction(node) {\n    return typeof node.config.modelComparatorFn === 'function';\n  }\n\n  Node.prototype.isRoot = function () {\n    return this.parent === undefined;\n  };\n\n  Node.prototype.hasChildren = function () {\n    return this.children.length > 0;\n  };\n\n  function addChild(self, child, insertIndex) {\n    var index;\n\n    if (!(child instanceof Node)) {\n      throw new TypeError('Child must be of type Node.');\n    }\n\n    child.parent = self;\n    if (!(self.model[self.config.childrenPropertyName] instanceof Array)) {\n      self.model[self.config.childrenPropertyName] = [];\n    }\n\n    if (hasComparatorFunction(self)) {\n      // Find the index to insert the child\n      index = findInsertIndex(\n        self.config.modelComparatorFn,\n        self.model[self.config.childrenPropertyName],\n        child.model);\n\n      // Add to the model children\n      self.model[self.config.childrenPropertyName].splice(index, 0, child.model);\n\n      // Add to the node children\n      self.children.splice(index, 0, child);\n    } else {\n      if (insertIndex === undefined) {\n        self.model[self.config.childrenPropertyName].push(child.model);\n        self.children.push(child);\n      } else {\n        if (insertIndex < 0 || insertIndex > self.children.length) {\n          throw new Error('Invalid index.');\n        }\n        self.model[self.config.childrenPropertyName].splice(insertIndex, 0, child.model);\n        self.children.splice(insertIndex, 0, child);\n      }\n    }\n    return child;\n  }\n\n  Node.prototype.addChild = function (child) {\n    return addChild(this, child);\n  };\n\n  Node.prototype.addChildAtIndex = function (child, index) {\n    if (hasComparatorFunction(this)) {\n      throw new Error('Cannot add child at index when using a comparator function.');\n    }\n\n    return addChild(this, child, index);\n  };\n\n  Node.prototype.setIndex = function (index) {\n    if (hasComparatorFunction(this)) {\n      throw new Error('Cannot set node index when using a comparator function.');\n    }\n\n    if (this.isRoot()) {\n      if (index === 0) {\n        return this;\n      }\n      throw new Error('Invalid index.');\n    }\n\n    if (index < 0 || index >= this.parent.children.length) {\n      throw new Error('Invalid index.');\n    }\n\n    var oldIndex = this.parent.children.indexOf(this);\n\n    this.parent.children.splice(index, 0, this.parent.children.splice(oldIndex, 1)[0]);\n\n    this.parent.model[this.parent.config.childrenPropertyName]\n      .splice(index, 0, this.parent.model[this.parent.config.childrenPropertyName].splice(oldIndex, 1)[0]);\n\n    return this;\n  };\n\n  Node.prototype.getPath = function () {\n    var path = [];\n    (function addToPath(node) {\n      path.unshift(node);\n      if (!node.isRoot()) {\n        addToPath(node.parent);\n      }\n    })(this);\n    return path;\n  };\n\n  Node.prototype.getIndex = function () {\n    if (this.isRoot()) {\n      return 0;\n    }\n    return this.parent.children.indexOf(this);\n  };\n\n  /**\n   * Parse the arguments of traversal functions. These functions can take one optional\n   * first argument which is an options object. If present, this object will be stored\n   * in args.options. The only mandatory argument is the callback function which can\n   * appear in the first or second position (if an options object is given). This\n   * function will be saved to args.fn. The last optional argument is the context on\n   * which the callback function will be called. It will be available in args.ctx.\n   *\n   * @returns Parsed arguments.\n   */\n  function parseArgs() {\n    var args = {};\n    if (arguments.length === 1) {\n      if (typeof arguments[0] === 'function') {\n        args.fn = arguments[0];\n      } else {\n        args.options = arguments[0];\n      }\n    } else if (arguments.length === 2) {\n      if (typeof arguments[0] === 'function') {\n        args.fn = arguments[0];\n        args.ctx = arguments[1];\n      } else {\n        args.options = arguments[0];\n        args.fn = arguments[1];\n      }\n    } else {\n      args.options = arguments[0];\n      args.fn = arguments[1];\n      args.ctx = arguments[2];\n    }\n    args.options = args.options || {};\n    if (!args.options.strategy) {\n      args.options.strategy = 'pre';\n    }\n    if (!walkStrategies[args.options.strategy]) {\n      throw new Error('Unknown tree walk strategy. Valid strategies are \\'pre\\' [default], \\'post\\' and \\'breadth\\'.');\n    }\n    return args;\n  }\n\n  Node.prototype.walk = function () {\n    var args;\n    args = parseArgs.apply(this, arguments);\n    walkStrategies[args.options.strategy].call(this, args.fn, args.ctx);\n  };\n\n  walkStrategies.pre = function depthFirstPreOrder(callback, context) {\n    var i, childCount, keepGoing;\n    keepGoing = callback.call(context, this);\n    for (i = 0, childCount = this.children.length; i < childCount; i++) {\n      if (keepGoing === false) {\n        return false;\n      }\n      keepGoing = depthFirstPreOrder.call(this.children[i], callback, context);\n    }\n    return keepGoing;\n  };\n\n  walkStrategies.post = function depthFirstPostOrder(callback, context) {\n    var i, childCount, keepGoing;\n    for (i = 0, childCount = this.children.length; i < childCount; i++) {\n      keepGoing = depthFirstPostOrder.call(this.children[i], callback, context);\n      if (keepGoing === false) {\n        return false;\n      }\n    }\n    keepGoing = callback.call(context, this);\n    return keepGoing;\n  };\n\n  walkStrategies.breadth = function breadthFirst(callback, context) {\n    var queue = [this];\n    (function processQueue() {\n      var i, childCount, node;\n      if (queue.length === 0) {\n        return;\n      }\n      node = queue.shift();\n      for (i = 0, childCount = node.children.length; i < childCount; i++) {\n        queue.push(node.children[i]);\n      }\n      if (callback.call(context, node) !== false) {\n        processQueue();\n      }\n    })();\n  };\n\n  Node.prototype.all = function () {\n    var args, all = [];\n    args = parseArgs.apply(this, arguments);\n    args.fn = args.fn || k(true);\n    walkStrategies[args.options.strategy].call(this, function (node) {\n      if (args.fn.call(args.ctx, node)) {\n        all.push(node);\n      }\n    }, args.ctx);\n    return all;\n  };\n\n  Node.prototype.first = function () {\n    var args, first;\n    args = parseArgs.apply(this, arguments);\n    args.fn = args.fn || k(true);\n    walkStrategies[args.options.strategy].call(this, function (node) {\n      if (args.fn.call(args.ctx, node)) {\n        first = node;\n        return false;\n      }\n    }, args.ctx);\n    return first;\n  };\n\n  Node.prototype.drop = function () {\n    var indexOfChild;\n    if (!this.isRoot()) {\n      indexOfChild = this.parent.children.indexOf(this);\n      this.parent.children.splice(indexOfChild, 1);\n      this.parent.model[this.config.childrenPropertyName].splice(indexOfChild, 1);\n      this.parent = undefined;\n      delete this.parent;\n    }\n    return this;\n  };\n\n  return TreeModel;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHJlZS1tb2RlbC9pbmRleC5qcz83M2VjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLG9EQUFXO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLG9FQUFtQjs7QUFFN0M7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsZ0JBQWdCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHJlZS1tb2RlbC9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBtZXJnZVNvcnQsIGZpbmRJbnNlcnRJbmRleDtcbm1lcmdlU29ydCA9IHJlcXVpcmUoJ21lcmdlc29ydCcpO1xuZmluZEluc2VydEluZGV4ID0gcmVxdWlyZSgnZmluZC1pbnNlcnQtaW5kZXgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHdhbGtTdHJhdGVnaWVzO1xuXG4gIHdhbGtTdHJhdGVnaWVzID0ge307XG5cbiAgZnVuY3Rpb24gayhyZXN1bHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gVHJlZU1vZGVsKGNvbmZpZykge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmNvbmZpZy5jaGlsZHJlblByb3BlcnR5TmFtZSA9IGNvbmZpZy5jaGlsZHJlblByb3BlcnR5TmFtZSB8fCAnY2hpbGRyZW4nO1xuICAgIHRoaXMuY29uZmlnLm1vZGVsQ29tcGFyYXRvckZuID0gY29uZmlnLm1vZGVsQ29tcGFyYXRvckZuO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkQ2hpbGRUb05vZGUobm9kZSwgY2hpbGQpIHtcbiAgICBjaGlsZC5wYXJlbnQgPSBub2RlO1xuICAgIG5vZGUuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gTm9kZShjb25maWcsIG1vZGVsKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgfVxuXG4gIFRyZWVNb2RlbC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICB2YXIgaSwgY2hpbGRDb3VudCwgbm9kZTtcblxuICAgIGlmICghKG1vZGVsIGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTW9kZWwgbXVzdCBiZSBvZiB0eXBlIG9iamVjdC4nKTtcbiAgICB9XG5cbiAgICBub2RlID0gbmV3IE5vZGUodGhpcy5jb25maWcsIG1vZGVsKTtcbiAgICBpZiAobW9kZWxbdGhpcy5jb25maWcuY2hpbGRyZW5Qcm9wZXJ0eU5hbWVdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5tb2RlbENvbXBhcmF0b3JGbikge1xuICAgICAgICBtb2RlbFt0aGlzLmNvbmZpZy5jaGlsZHJlblByb3BlcnR5TmFtZV0gPSBtZXJnZVNvcnQoXG4gICAgICAgICAgdGhpcy5jb25maWcubW9kZWxDb21wYXJhdG9yRm4sXG4gICAgICAgICAgbW9kZWxbdGhpcy5jb25maWcuY2hpbGRyZW5Qcm9wZXJ0eU5hbWVdKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDAsIGNoaWxkQ291bnQgPSBtb2RlbFt0aGlzLmNvbmZpZy5jaGlsZHJlblByb3BlcnR5TmFtZV0ubGVuZ3RoOyBpIDwgY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgIGFkZENoaWxkVG9Ob2RlKG5vZGUsIHRoaXMucGFyc2UobW9kZWxbdGhpcy5jb25maWcuY2hpbGRyZW5Qcm9wZXJ0eU5hbWVdW2ldKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGhhc0NvbXBhcmF0b3JGdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBub2RlLmNvbmZpZy5tb2RlbENvbXBhcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIE5vZGUucHJvdG90eXBlLmlzUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQgPT09IHVuZGVmaW5lZDtcbiAgfTtcblxuICBOb2RlLnByb3RvdHlwZS5oYXNDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFkZENoaWxkKHNlbGYsIGNoaWxkLCBpbnNlcnRJbmRleCkge1xuICAgIHZhciBpbmRleDtcblxuICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgTm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoaWxkIG11c3QgYmUgb2YgdHlwZSBOb2RlLicpO1xuICAgIH1cblxuICAgIGNoaWxkLnBhcmVudCA9IHNlbGY7XG4gICAgaWYgKCEoc2VsZi5tb2RlbFtzZWxmLmNvbmZpZy5jaGlsZHJlblByb3BlcnR5TmFtZV0gaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIHNlbGYubW9kZWxbc2VsZi5jb25maWcuY2hpbGRyZW5Qcm9wZXJ0eU5hbWVdID0gW107XG4gICAgfVxuXG4gICAgaWYgKGhhc0NvbXBhcmF0b3JGdW5jdGlvbihzZWxmKSkge1xuICAgICAgLy8gRmluZCB0aGUgaW5kZXggdG8gaW5zZXJ0IHRoZSBjaGlsZFxuICAgICAgaW5kZXggPSBmaW5kSW5zZXJ0SW5kZXgoXG4gICAgICAgIHNlbGYuY29uZmlnLm1vZGVsQ29tcGFyYXRvckZuLFxuICAgICAgICBzZWxmLm1vZGVsW3NlbGYuY29uZmlnLmNoaWxkcmVuUHJvcGVydHlOYW1lXSxcbiAgICAgICAgY2hpbGQubW9kZWwpO1xuXG4gICAgICAvLyBBZGQgdG8gdGhlIG1vZGVsIGNoaWxkcmVuXG4gICAgICBzZWxmLm1vZGVsW3NlbGYuY29uZmlnLmNoaWxkcmVuUHJvcGVydHlOYW1lXS5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkLm1vZGVsKTtcblxuICAgICAgLy8gQWRkIHRvIHRoZSBub2RlIGNoaWxkcmVuXG4gICAgICBzZWxmLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW5zZXJ0SW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWxmLm1vZGVsW3NlbGYuY29uZmlnLmNoaWxkcmVuUHJvcGVydHlOYW1lXS5wdXNoKGNoaWxkLm1vZGVsKTtcbiAgICAgICAgc2VsZi5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbnNlcnRJbmRleCA8IDAgfHwgaW5zZXJ0SW5kZXggPiBzZWxmLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbmRleC4nKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLm1vZGVsW3NlbGYuY29uZmlnLmNoaWxkcmVuUHJvcGVydHlOYW1lXS5zcGxpY2UoaW5zZXJ0SW5kZXgsIDAsIGNoaWxkLm1vZGVsKTtcbiAgICAgICAgc2VsZi5jaGlsZHJlbi5zcGxpY2UoaW5zZXJ0SW5kZXgsIDAsIGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG5cbiAgTm9kZS5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gYWRkQ2hpbGQodGhpcywgY2hpbGQpO1xuICB9O1xuXG4gIE5vZGUucHJvdG90eXBlLmFkZENoaWxkQXRJbmRleCA9IGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpIHtcbiAgICBpZiAoaGFzQ29tcGFyYXRvckZ1bmN0aW9uKHRoaXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgY2hpbGQgYXQgaW5kZXggd2hlbiB1c2luZyBhIGNvbXBhcmF0b3IgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZENoaWxkKHRoaXMsIGNoaWxkLCBpbmRleCk7XG4gIH07XG5cbiAgTm9kZS5wcm90b3R5cGUuc2V0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICBpZiAoaGFzQ29tcGFyYXRvckZ1bmN0aW9uKHRoaXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgbm9kZSBpbmRleCB3aGVuIHVzaW5nIGEgY29tcGFyYXRvciBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1Jvb3QoKSkge1xuICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGluZGV4LicpO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5wYXJlbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5kZXguJyk7XG4gICAgfVxuXG4gICAgdmFyIG9sZEluZGV4ID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcblxuICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKG9sZEluZGV4LCAxKVswXSk7XG5cbiAgICB0aGlzLnBhcmVudC5tb2RlbFt0aGlzLnBhcmVudC5jb25maWcuY2hpbGRyZW5Qcm9wZXJ0eU5hbWVdXG4gICAgICAuc3BsaWNlKGluZGV4LCAwLCB0aGlzLnBhcmVudC5tb2RlbFt0aGlzLnBhcmVudC5jb25maWcuY2hpbGRyZW5Qcm9wZXJ0eU5hbWVdLnNwbGljZShvbGRJbmRleCwgMSlbMF0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgTm9kZS5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGF0aCA9IFtdO1xuICAgIChmdW5jdGlvbiBhZGRUb1BhdGgobm9kZSkge1xuICAgICAgcGF0aC51bnNoaWZ0KG5vZGUpO1xuICAgICAgaWYgKCFub2RlLmlzUm9vdCgpKSB7XG4gICAgICAgIGFkZFRvUGF0aChub2RlLnBhcmVudCk7XG4gICAgICB9XG4gICAgfSkodGhpcyk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG5cbiAgTm9kZS5wcm90b3R5cGUuZ2V0SW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNSb290KCkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2UgdGhlIGFyZ3VtZW50cyBvZiB0cmF2ZXJzYWwgZnVuY3Rpb25zLiBUaGVzZSBmdW5jdGlvbnMgY2FuIHRha2Ugb25lIG9wdGlvbmFsXG4gICAqIGZpcnN0IGFyZ3VtZW50IHdoaWNoIGlzIGFuIG9wdGlvbnMgb2JqZWN0LiBJZiBwcmVzZW50LCB0aGlzIG9iamVjdCB3aWxsIGJlIHN0b3JlZFxuICAgKiBpbiBhcmdzLm9wdGlvbnMuIFRoZSBvbmx5IG1hbmRhdG9yeSBhcmd1bWVudCBpcyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggY2FuXG4gICAqIGFwcGVhciBpbiB0aGUgZmlyc3Qgb3Igc2Vjb25kIHBvc2l0aW9uIChpZiBhbiBvcHRpb25zIG9iamVjdCBpcyBnaXZlbikuIFRoaXNcbiAgICogZnVuY3Rpb24gd2lsbCBiZSBzYXZlZCB0byBhcmdzLmZuLiBUaGUgbGFzdCBvcHRpb25hbCBhcmd1bWVudCBpcyB0aGUgY29udGV4dCBvblxuICAgKiB3aGljaCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQuIEl0IHdpbGwgYmUgYXZhaWxhYmxlIGluIGFyZ3MuY3R4LlxuICAgKlxuICAgKiBAcmV0dXJucyBQYXJzZWQgYXJndW1lbnRzLlxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VBcmdzKCkge1xuICAgIHZhciBhcmdzID0ge307XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGFyZ3MuZm4gPSBhcmd1bWVudHNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcmdzLm9wdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBhcmdzLmZuID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBhcmdzLmN0eCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3Mub3B0aW9ucyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgYXJncy5mbiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXJncy5vcHRpb25zID0gYXJndW1lbnRzWzBdO1xuICAgICAgYXJncy5mbiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGFyZ3MuY3R4ID0gYXJndW1lbnRzWzJdO1xuICAgIH1cbiAgICBhcmdzLm9wdGlvbnMgPSBhcmdzLm9wdGlvbnMgfHwge307XG4gICAgaWYgKCFhcmdzLm9wdGlvbnMuc3RyYXRlZ3kpIHtcbiAgICAgIGFyZ3Mub3B0aW9ucy5zdHJhdGVneSA9ICdwcmUnO1xuICAgIH1cbiAgICBpZiAoIXdhbGtTdHJhdGVnaWVzW2FyZ3Mub3B0aW9ucy5zdHJhdGVneV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0cmVlIHdhbGsgc3RyYXRlZ3kuIFZhbGlkIHN0cmF0ZWdpZXMgYXJlIFxcJ3ByZVxcJyBbZGVmYXVsdF0sIFxcJ3Bvc3RcXCcgYW5kIFxcJ2JyZWFkdGhcXCcuJyk7XG4gICAgfVxuICAgIHJldHVybiBhcmdzO1xuICB9XG5cbiAgTm9kZS5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncztcbiAgICBhcmdzID0gcGFyc2VBcmdzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgd2Fsa1N0cmF0ZWdpZXNbYXJncy5vcHRpb25zLnN0cmF0ZWd5XS5jYWxsKHRoaXMsIGFyZ3MuZm4sIGFyZ3MuY3R4KTtcbiAgfTtcblxuICB3YWxrU3RyYXRlZ2llcy5wcmUgPSBmdW5jdGlvbiBkZXB0aEZpcnN0UHJlT3JkZXIoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB2YXIgaSwgY2hpbGRDb3VudCwga2VlcEdvaW5nO1xuICAgIGtlZXBHb2luZyA9IGNhbGxiYWNrLmNhbGwoY29udGV4dCwgdGhpcyk7XG4gICAgZm9yIChpID0gMCwgY2hpbGRDb3VudCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICBpZiAoa2VlcEdvaW5nID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBrZWVwR29pbmcgPSBkZXB0aEZpcnN0UHJlT3JkZXIuY2FsbCh0aGlzLmNoaWxkcmVuW2ldLCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBrZWVwR29pbmc7XG4gIH07XG5cbiAgd2Fsa1N0cmF0ZWdpZXMucG9zdCA9IGZ1bmN0aW9uIGRlcHRoRmlyc3RQb3N0T3JkZXIoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB2YXIgaSwgY2hpbGRDb3VudCwga2VlcEdvaW5nO1xuICAgIGZvciAoaSA9IDAsIGNoaWxkQ291bnQgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGNoaWxkQ291bnQ7IGkrKykge1xuICAgICAga2VlcEdvaW5nID0gZGVwdGhGaXJzdFBvc3RPcmRlci5jYWxsKHRoaXMuY2hpbGRyZW5baV0sIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICAgIGlmIChrZWVwR29pbmcgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAga2VlcEdvaW5nID0gY2FsbGJhY2suY2FsbChjb250ZXh0LCB0aGlzKTtcbiAgICByZXR1cm4ga2VlcEdvaW5nO1xuICB9O1xuXG4gIHdhbGtTdHJhdGVnaWVzLmJyZWFkdGggPSBmdW5jdGlvbiBicmVhZHRoRmlyc3QoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB2YXIgcXVldWUgPSBbdGhpc107XG4gICAgKGZ1bmN0aW9uIHByb2Nlc3NRdWV1ZSgpIHtcbiAgICAgIHZhciBpLCBjaGlsZENvdW50LCBub2RlO1xuICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlID0gcXVldWUuc2hpZnQoKTtcbiAgICAgIGZvciAoaSA9IDAsIGNoaWxkQ291bnQgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICBxdWV1ZS5wdXNoKG5vZGUuY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrLmNhbGwoY29udGV4dCwgbm9kZSkgIT09IGZhbHNlKSB7XG4gICAgICAgIHByb2Nlc3NRdWV1ZSgpO1xuICAgICAgfVxuICAgIH0pKCk7XG4gIH07XG5cbiAgTm9kZS5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzLCBhbGwgPSBbXTtcbiAgICBhcmdzID0gcGFyc2VBcmdzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgYXJncy5mbiA9IGFyZ3MuZm4gfHwgayh0cnVlKTtcbiAgICB3YWxrU3RyYXRlZ2llc1thcmdzLm9wdGlvbnMuc3RyYXRlZ3ldLmNhbGwodGhpcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmIChhcmdzLmZuLmNhbGwoYXJncy5jdHgsIG5vZGUpKSB7XG4gICAgICAgIGFsbC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH0sIGFyZ3MuY3R4KTtcbiAgICByZXR1cm4gYWxsO1xuICB9O1xuXG4gIE5vZGUucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzLCBmaXJzdDtcbiAgICBhcmdzID0gcGFyc2VBcmdzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgYXJncy5mbiA9IGFyZ3MuZm4gfHwgayh0cnVlKTtcbiAgICB3YWxrU3RyYXRlZ2llc1thcmdzLm9wdGlvbnMuc3RyYXRlZ3ldLmNhbGwodGhpcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmIChhcmdzLmZuLmNhbGwoYXJncy5jdHgsIG5vZGUpKSB7XG4gICAgICAgIGZpcnN0ID0gbm9kZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIGFyZ3MuY3R4KTtcbiAgICByZXR1cm4gZmlyc3Q7XG4gIH07XG5cbiAgTm9kZS5wcm90b3R5cGUuZHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5kZXhPZkNoaWxkO1xuICAgIGlmICghdGhpcy5pc1Jvb3QoKSkge1xuICAgICAgaW5kZXhPZkNoaWxkID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcbiAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleE9mQ2hpbGQsIDEpO1xuICAgICAgdGhpcy5wYXJlbnQubW9kZWxbdGhpcy5jb25maWcuY2hpbGRyZW5Qcm9wZXJ0eU5hbWVdLnNwbGljZShpbmRleE9mQ2hpbGQsIDEpO1xuICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICBkZWxldGUgdGhpcy5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBUcmVlTW9kZWw7XG59KSgpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tree-model/index.js\n");

/***/ })

}]);